% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fays_generalized_replication.R
\name{make_fays_gen_rep_factors}
\alias{make_fays_gen_rep_factors}
\title{Form replication factors using Fay's generalized replication method}
\usage{
make_fays_gen_rep_factors(Sigma, max_replicates)
}
\arguments{
\item{Sigma}{A quadratic form matrix corresponding to
a target variance estimator. Must be positive semidefinite.}

\item{max_replicates}{The maximum number of replicates to allow.
The function will attempt to create the minimum number of replicates
needed to produce a fully-efficient variance estimator.
If more replicates are needed than \code{max_replicates}, then the full number of replicates
needed will be created, but only a random subsample will be retained.}
}
\value{
A matrix of replicate factors,
with the number of rows matching the number of rows of \code{Sigma}
and the number of columns less than or equal to \code{max_replicates}.
To calculate variance estimates using these factors,
use the overall scale factor given by calling
\code{attr(x, "scale")} on the result.
}
\description{
Generate a matrix of replication factors
using Fay's generalized replication method.
This method yields a fully efficient variance estimator
if a sufficient number of replicates is used.
}
\section{Statistical Details}{

See Fay (1989) for a full explanation of Fay's generalized replication method.
This documentation provides a brief overview.

Let \eqn{\boldsymbol{\Sigma}} be the quadratic form matrix for a target variance estimator,
which is assumed to be positive semidefinite.
Suppose the rank of \eqn{\boldsymbol{\Sigma}} is \eqn{k},
and so \eqn{\boldsymbol{\Sigma}} can be represented by the spectral decomposition
of \eqn{k} eigenvectors and eigenvalues, where the \eqn{r}-th eigenvector and eigenvalue
are denoted \eqn{\mathbf{v}_{(r)}} and \eqn{\lambda_r}, respectively.
\deqn{
\boldsymbol{\Sigma} = \sum_{r=1}^k \lambda_r \mathbf{v}_{(r)} \mathbf{v^{\prime}}_{(r)}
}
Let \eqn{\mathbf{H}} be a Hadamard matrix (with all entries equal to \eqn{1} or \eqn{-1}),
of order \eqn{k^{\prime} \geq k}. Let \eqn{\mathbf{H}_{mr}} denote the entry in row
\eqn{m} and column \eqn{r} of \eqn{\mathbf{H}}.

Then \eqn{k^{\prime}} replicates are formed as follows.
Let \eqn{r} denote a given replicate, with \eqn{r = 1, ..., k^{\prime}},
and let \eqn{c} denote some positive constant (yet to be specified).


For now, let \eqn{c=1} and create the \eqn{r}-th replicate's adjustment factor \eqn{\mathbf{f}_{r}} as:
\deqn{
  \mathbf{f}_{r} = 1 + c \sum_{m=1}^k H_{m r} \lambda^{\frac{1}{2}} v_{(m)}
}

It's possible that one or more of the replicates will have a negative adjustment factor.
This can easily be eliminated by an appropriate choice of the constant \eqn{c}.
If there are any negative adjustment factors,
then set \eqn{c^{-1}} equal to some value just larger than the
absolute value of the minimum replicate adjustment factor (from across all the replicates).
Then recalculate \eqn{\mathbf{f}_{r}} using the updated value of \eqn{c}.
This function uses a value of \eqn{c=1}. You can update the value
of \eqn{c} after creating replicate factors
by using the function \code{\link[svrep]{rescale_reps}}.

If all \eqn{k^{\prime}} replicates are used, then variance estimates are calculated as:
\deqn{
  v_{rep}\left(\hat{T}_y\right) = \frac{c^2}{k^{\prime}} \sum_{r=1}^{k^{\prime}}\left(\hat{T}_y^{*(r)}-\hat{T}_y\right)^2
}
For population totals, this replication variance estimator
will \emph{exactly} match the target variance estimator.

If the number of replicates \eqn{k^{\prime}} is too large for practical purposes,
then one can simply retain only a random subset of \eqn{R} of the \eqn{k^{\prime}} replicates.
In this case, variances are calculated as follows:
\deqn{
  v_{rep}\left(\hat{T}_y\right) = \frac{c^2}{R} \sum_{r=1}^{R}\left(\hat{T}_y^{*(r)}-\hat{T}_y\right)^2
}
This is what happens if \code{max_replicates} is less than the
matrix rank of \code{Sigma}: only a random subset
of the created replicates will be retained.

The Hadamard matrix used in the construction of replicates
is deterministically created using the function
\code{\link[survey]{hadamard}} from the 'survey' package.
However, the order of rows/columns is randomly permuted.
To ensure exact reproducibility, it is recommended to call
\code{\link[base]{set.seed}} before using this function.
}

\examples{
  library(survey)

# Load an example dataset that uses unequal probability sampling ----
  data('election', package = 'survey')

# Create matrix to represent the Horvitz-Thompson estimator as a quadratic form ----
  n <- nrow(election_pps)
  pi <- election_jointprob
  horvitz_thompson_matrix <- matrix(nrow = n, ncol = n)
  for (i in seq_len(n)) {
    for (j in seq_len(n)) {
      horvitz_thompson_matrix[i,j] <- 1 - (pi[i,i] * pi[j,j])/pi[i,j]
    }
  }

  ## Equivalently:

  horvitz_thompson_matrix <- make_quad_form_matrix(
    variance_estimator = "Horvitz-Thompson",
    joint_probs = election_jointprob
  )

# Make generalized replication adjustment factors ----

  adjustment_factors <- make_fays_gen_rep_factors(
    Sigma = horvitz_thompson_matrix,
    max_replicates = 50
  )
  attr(adjustment_factors, 'scale')

# Compute the Horvitz-Thompson estimate and the replication estimate

ht_estimate <- svydesign(data = election_pps, ids = ~ 1,
                         prob = diag(election_jointprob),
                         pps = ppsmat(election_jointprob)) |>
  svytotal(x = ~ Kerry)

rep_estimate <- svrepdesign(
  data = election_pps,
  weights = ~ wt,
  repweights = adjustment_factors,
  combined.weights = FALSE,
  scale = attr(adjustment_factors, 'scale'),
  rscales = rep(1, times = ncol(adjustment_factors)),
  type = "other"
) |>
  svytotal(x = ~ Kerry)

SE(rep_estimate)
SE(ht_estimate)
SE(rep_estimate) / SE(ht_estimate)
}
\references{
Fay, Robert. 1989.
"Theory And Application Of Replicate Weighting For Variance Calculations."
In, 495â€“500. Alexandria, VA: American Statistical Association.
http://www.asasrms.org/Proceedings/papers/1989_033.pdf
}
\seealso{
Use \code{\link[svrep]{rescale_reps}} to eliminate negative adjustment factors.
}
