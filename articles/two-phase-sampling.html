<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="svrep">
<title>Replication Methods for Two-phase Sampling • svrep</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Replication Methods for Two-phase Sampling">
<meta property="og:description" content="svrep">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">svrep</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.6.0.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/bootstrap-replicates.html">Bootstrap Methods for Surveys</a>
    <a class="dropdown-item" href="../articles/nonresponse-adjustments.html">Nonresponse Adjustments</a>
    <a class="dropdown-item" href="../articles/sample-based-calibration.html">Calibrating to Estimated Control Totals</a>
    <a class="dropdown-item" href="../articles/two-phase-sampling.html">Replication Methods for Two-phase Sampling</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/bschneidr/svrep/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Replication Methods for Two-phase Sampling</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/bschneidr/svrep/blob/HEAD/vignettes/two-phase-sampling.Rmd" class="external-link"><code>vignettes/two-phase-sampling.Rmd</code></a></small>
      <div class="d-none name"><code>two-phase-sampling.Rmd</code></div>
    </div>

    
    
<p>This vignette provides an overview of two-phase sampling and how the
‘svrep’ package can be used to estimate sampling variances for
estimators that are commonly-used in two-phase sampling. Readers who are
already familiar with two-phase sampling and its applications are
encouraged to skip to Section 3 of this vignette for a description of
variance estimators and their implementation in the ‘svrep’ package.</p>
<div class="section level2">
<h2 id="two-phase-sampling-vs--multistage-sampling">Two-phase Sampling vs. Multistage Sampling<a class="anchor" aria-label="anchor" href="#two-phase-sampling-vs--multistage-sampling"></a>
</h2>
<p>Two-phase sampling (also known as “double sampling”) is a common
feature in surveys. In a two-phase sample, a large first-phase sample is
selected, and a smaller second-phase sample is selected from the
first-phase sample. Multistage cluster sampling is a special case of
two-phase sampling, where a second-phase sample of secondary sampling
units (SSUs) are selected from a first-phase sample of primary sampling
units (PSUs). In the specific case of multistage sampling, the
second-phase sampling of SSUs must sample at least one SSU from within
each PSU and must sample independently across PSUs (in other words, each
PSU is treated as a stratum in second-phase sampling). Two-phase
sampling in general does not have these restrictions: the second-phase
sample design can be arbitrary, and some primary sampling units might
not appear at all in the second-phase sample.</p>
</div>
<div class="section level2">
<h2 id="applications-of-two-phase-sampling">Applications of Two-Phase Sampling<a class="anchor" aria-label="anchor" href="#applications-of-two-phase-sampling"></a>
</h2>
<p>The flexibility of two-phase sampling can be quite valuable, and for
this reason two-phase samples are commonly-used in practice. We
highlight two common applications of two-phase sampling below:</p>
<ul>
<li><p>Any given survey conducted using an online panel is necessarily a
two-phase sample, where the panel recruitment represents the first phase
of sampling and the process of requesting panelists to participate in a
specific survey represents the second phase of sampling. Often, the
recruitment sampling is quite complex (e.g., three-stage stratified
cluster sampling), but the sampling of panelists for a given survey is
conducted using simple random sampling or stratified simple random
sampling from the list of panelists.</p></li>
<li><p>Statistical agencies often reduce the cost of a small survey by
drawing its sample from respondents to a larger survey that’s already
being conducted. For example, the U.S. Census Bureau conducts the <a href="https://www.nsf.gov/statistics/srvygrads" class="external-link">National Survey of
College Graduates (NSCG)</a> by sampling from households that responded
to the <a href="https://www.census.gov/programs-surveys/acs/" class="external-link">American
Community Survey (ACS)</a>. Similarly, the <a href="https://nhats.org/researcher/nsoc" class="external-link">National Study of Caregiving
(NSOC)</a> is conducted by sampling respondents to the <a href="https://nhats.org/researcher/nhats" class="external-link">National Health and Aging
Trends Study (NHATS)</a>.</p></li>
</ul>
<p>The information from the first-phase sample is useful for both design
and analysis of the second-phase sample. From a design standpoint,
information collected in the first-phase sample can be used to stratify
units or assign unequal sampling probabilities for the second-phase
sampling, which can result in more precise estimates relative to using
simple random sampling. From an analysis standpoint, the information
collected in the first-phase sample can also be used to improve
estimators, by using raking, post-stratification, or generalized
regression (GREG) to calibrate the small second-phase sample to the
large first-phase sample.</p>
<!-- ## Application 2: Reducing Sampling Variances -->
<!-- Two-phase sampling is useful when some variables are expensive to measure and thus can only be measured in a small sample, but some closely-correlated variables can be measured inexpensively through a larger survey. For example, highly-accurate blood tests for Covid-19 infection are expensive and can only be measured using a small survey, whereas self-reported Covid-19 infection can be inexpensively measured using a large questionnaire-based survey. **By drawing our small sample from the larger sample and using the auxiliary data from the large sample to help select the small sample and produce estimates from it, we can produce estimates using the small sample which are more precise than if we had simply drawn a small, single-phase simple random sample.** -->
</div>
<div class="section level2">
<h2 id="replicate-variance-estimation-with-the-svrep-package">Replicate Variance Estimation with the ‘svrep’ Package<a class="anchor" aria-label="anchor" href="#replicate-variance-estimation-with-the-svrep-package"></a>
</h2>
<p>In this vignette, we’ll show how to use the generalized bootstrap to
estimate sampling variances for estimates based on two-phase sample
designs. Other types of replication such as the jackknife or balanced
repeated replication (BRR) can theoretically be used, but the ‘svrep’
package only implements two-phase replication methods for the
generalized bootstrap and for Fay’s generalized replication method. In
theory, other replication methods can be used for two-phase samples, but
their applicability is much more limited.</p>
<div class="section level3">
<h3 id="overview-of-the-generalized-bootstrap">Overview of the Generalized Bootstrap<a class="anchor" aria-label="anchor" href="#overview-of-the-generalized-bootstrap"></a>
</h3>
<p>The basic idea of the generalized bootstrap is to “mimic” a target
variance estimator for population totals, where the target variance
estimator is appropriate to the particular sampling design and can be
written down as a quadratic form. For example, the generalized bootstrap
can mimic the Horvitz-Thompson estimator or the usual variance estimator
used for simple random sampling. To be more precise, by “mimic”, we mean
that the generalized bootstrap variance estimate for a population total
on average exactly matches the variance estimate produced by the target
variance estimator.</p>
<p>In order to mimic a target variance estimator, we have to specify the
target variance estimator for a population total <span class="math inline">\(\hat{Y}=\sum_{i=1}^{n}(y_i/\pi_i)\)</span> as a
quadratic form. That is, we have to specify a variance estimator <span class="math inline">\(v(\hat{Y})\)</span> as <span class="math inline">\(v(\hat{Y})=\sum_{i=1}^{n}\sum_{i=1}^{n}
\sigma_{ij}(w_iy_i)(w_jy_j)\)</span>, for some set of values <span class="math inline">\(\sigma_{ij},i,j \in \{1,\dots,n\}\)</span>. In
matrix notation, we write <span class="math inline">\(v(\hat{Y})=\breve{y}^{\prime}\Sigma\breve{y}\)</span>,
where <span class="math inline">\(\Sigma\)</span> is the symmetric,
positive semi-definite matrix of dimension <span class="math inline">\(n
\times n\)</span>, with element <span class="math inline">\(ij\)</span>
equal to <span class="math inline">\(\sigma_{ij}\)</span>, and <span class="math inline">\(\breve{y}\)</span> is a vector whose <span class="math inline">\(i\)</span>-th element is <span class="math inline">\(w_iy_i\)</span>.</p>
<p>When using the generalized bootstrap, the difficult part of the
variance estimation process is simply identifying the quadratic form.
Once the quadratic form has been written down, it is easy to create
replicate weights using the generalized bootstrap. Fortunately, the
‘svrep’ package can automatically identify the appropriate quadratic
form to use for variance estimators for many single-phase and two-phase
sample designs. The user simply needs to supply the necessary data,
describe the survey design, and select a target variance estimator to
use for each phase of sampling.</p>
<p>For a broad overview of the generalized survey bootstrap and its use
in the ‘svrep’ package, the reader is encouraged to read the ‘svrep’
package vignette titled “Bootstrap Methods for Surveys”. For a thorough
overview of the generalized survey bootstrap and its theory, <span class="citation">Beaumont and Patak (2012)</span> provide a clear
introduction and several useful suggestions for its implementation in
practice. The present vignette simply describes the application of the
generalized bootstrap to two-phase samples and how it can be implemented
with the ‘svrep’ package.</p>
</div>
<div class="section level3">
<h3 id="creating-example-data">Creating Example Data<a class="anchor" aria-label="anchor" href="#creating-example-data"></a>
</h3>
<p>In the example below, we create a two-phase survey design:</p>
<ul>
<li><p>The first phase is a stratified multistage sample, where the
first stage sample of PSUs was selected using unequal probability
sampling without replacement (PPSWOR) and the second stage sample was
selected using simple random sampling without replacement
(SRSWOR).</p></li>
<li><p>The second phase sample is a simple random sample without
replacement from the first phase sample.</p></li>
</ul>
<p>This type of design would be fairly typical for a survey conducted on
an online panel, where the panel recruitment uses a complex design but
the sampling of panelists for a given survey uses simple random sampling
of panelists.</p>
<p>The particular dataset we’ll use comes from the Public Libraries
Survey (PLS), an annual survey of public libraries in the U.S, with data
from FY2020.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">'library_multistage_sample'</span>, package <span class="op">=</span> <span class="st">'svrep'</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Load first-phase sample</span></span>
<span>  <span class="va">twophase_sample</span> <span class="op">&lt;-</span> <span class="va">library_multistage_sample</span></span>
<span></span>
<span><span class="co"># Select second-phase sample</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">2020</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="va">twophase_sample</span><span class="op">[[</span><span class="st">'SECOND_PHASE_SELECTION'</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu">sampling</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sampling/man/srswor.html" class="external-link">srswor</a></span><span class="op">(</span></span>
<span>    n <span class="op">=</span> <span class="fl">100</span>,</span>
<span>    N <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">twophase_sample</span><span class="op">)</span></span>
<span>  <span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/logical.html" class="external-link">as.logical</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="describing-the-two-phase-survey-design">Describing the Two-phase Survey Design<a class="anchor" aria-label="anchor" href="#describing-the-two-phase-survey-design"></a>
</h3>
<p>Next, we use the ‘survey’ package’s function <code><a href="https://rdrr.io/pkg/survey/man/twophase.html" class="external-link">twophase()</a></code>
to describe the sample design at each phase, in terms of stratification,
clustering, probabilities, and population sizes. Note that we use a
<code><a href="https://rdrr.io/r/base/list.html" class="external-link">list()</a></code> for most arguments, where the first element of the
list describes the first phase of sampling, and the second element of
the list describes the second phase of sampling.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Declare survey design</span></span>
<span>  <span class="va">twophase_design</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survey/man/twophase.html" class="external-link">twophase</a></span><span class="op">(</span></span>
<span>    method <span class="op">=</span> <span class="st">"full"</span>,</span>
<span>    data <span class="op">=</span> <span class="va">twophase_sample</span>,</span>
<span>    <span class="co"># Identify the subset of first-phase elements</span></span>
<span>    <span class="co"># which were selected into the second-phase sample</span></span>
<span>    subset <span class="op">=</span> <span class="op">~</span> <span class="va">SECOND_PHASE_SELECTION</span>,</span>
<span>    <span class="co"># Describe clusters, probabilities, and population sizes</span></span>
<span>    <span class="co"># at each phase of sampling</span></span>
<span>    id <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">~</span> <span class="va">PSU_ID</span> <span class="op">+</span> <span class="va">SSU_ID</span>,</span>
<span>              <span class="op">~</span> <span class="fl">1</span><span class="op">)</span>,</span>
<span>    probs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">~</span> <span class="va">PSU_SAMPLING_PROB</span> <span class="op">+</span> <span class="va">SSU_SAMPLING_PROB</span>,</span>
<span>                 <span class="cn">NULL</span><span class="op">)</span>,</span>
<span>    fpc <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">~</span> <span class="va">PSU_POP_SIZE</span> <span class="op">+</span> <span class="va">SSU_POP_SIZE</span>,</span>
<span>               <span class="cn">NULL</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="creating-generalized-bootstrap-replicates">Creating Generalized Bootstrap Replicates<a class="anchor" aria-label="anchor" href="#creating-generalized-bootstrap-replicates"></a>
</h3>
<p>Once the two-phase design has been described, we can use the
<code><a href="../reference/as_gen_boot_design.html">as_gen_boot_design()</a></code> function to create generalized
bootstrap replicate weights. This requires us to specify the desired
number of replicates and the target variance estimator for each phase of
sampling. Note that different target variance estimators may be used for
each phase, since each phase might have a very different design.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Obtain a generalized bootstrap replicates</span></span>
<span><span class="co"># based on </span></span>
<span><span class="co">#   - The phase 1 estimator is the usual variance estimator</span></span>
<span><span class="co">#     for stratified multistage simple random sampling</span></span>
<span><span class="co">#   - The phase 2 estimator is the usual variance estimator</span></span>
<span><span class="co">#     for single-stage simple random sampling</span></span>
<span></span>
<span><span class="va">twophase_boot_design</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/as_gen_boot_design.html">as_gen_boot_design</a></span><span class="op">(</span></span>
<span>  design <span class="op">=</span> <span class="va">twophase_design</span>,</span>
<span>  variance_estimator <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span>
<span>    <span class="st">"Phase 1"</span> <span class="op">=</span> <span class="st">"Stratified Multistage SRS"</span>,</span>
<span>    <span class="st">"Phase 2"</span> <span class="op">=</span> <span class="st">"Ultimate Cluster"</span></span>
<span>  <span class="op">)</span>,</span>
<span>  replicates <span class="op">=</span> <span class="fl">1000</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The result is a replicate survey design object which can be used for
estimation with the usual functions from the ‘survey’ and ‘srvyr’
packages.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">twophase_boot_design</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/pkg/survey/man/surveysummary.html" class="external-link">svymean</a></span><span class="op">(</span>x <span class="op">=</span> <span class="op">~</span> <span class="va">LIBRARIA</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="co">#&gt;            mean     SE</span></span>
<span><span class="co">#&gt; LIBRARIA 7.6044 1.8419</span></span></code></pre></div>
<p>When using <code><a href="../reference/as_gen_boot_design.html">as_gen_boot_design()</a></code> for two-phase designs,
it’s useful to know that you will often see a warning message about
needing to approximate the first-phase variance estimator’s quadratic
form.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">twophase_boot_design</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/as_gen_boot_design.html">as_gen_boot_design</a></span><span class="op">(</span></span>
<span>  design <span class="op">=</span> <span class="va">twophase_design</span>,</span>
<span>  variance_estimator <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span>
<span>    <span class="st">"Phase 1"</span> <span class="op">=</span> <span class="st">"Stratified Multistage SRS"</span>,</span>
<span>    <span class="st">"Phase 2"</span> <span class="op">=</span> <span class="st">"Ultimate Cluster"</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Warning in as_gen_boot_design.twophase2(design = twophase_design,</span></span>
<span><span class="co">#&gt; variance_estimator = list(`Phase 1` = "Stratified Multistage SRS", : The sample</span></span>
<span><span class="co">#&gt; quadratic form matrix for this design and variance estimator is not positive</span></span>
<span><span class="co">#&gt; semidefinite. It will be approximated by the nearest positive semidefinite</span></span>
<span><span class="co">#&gt; matrix.</span></span></code></pre></div>
<p>As you can see from the output above, the function emitted a warning
message. The generalized bootstrap works by mimicking a variance
estimator but requires that variance estimator to be represented as a
positive semidefinite qudratic form. In two-phase designs, however, it
is often the case that the usual variance estimator cannot be
represented exactly as a positive semidefinite quadratic form. In such
cases, <span class="citation">Beaumont and Patak (2012)</span> suggest
using an approximation of the actual quadratic form matrix by the most
similar positive semidefinite matrix. This approximation will in general
never lead to an underestimation of variance, and <span class="citation">Beaumont and Patak (2012)</span> argue that this should
only produce a small overestimate of variance in practice. Section 5 of
this vignette provides more details of this approximation.</p>
</div>
<div class="section level3">
<h3 id="create-replicates-using-fays-generalized-replication-method">Create Replicates Using Fay’s Generalized Replication Method<a class="anchor" aria-label="anchor" href="#create-replicates-using-fays-generalized-replication-method"></a>
</h3>
<p>Instead of the generalized bootstrap, we can instead use Fay’s
generalized replication method. The R code looks almost exactly the same
as for the generalized bootstrap.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">twophase_genrep_design</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/as_fays_gen_rep_design.html">as_fays_gen_rep_design</a></span><span class="op">(</span></span>
<span>  design <span class="op">=</span> <span class="va">twophase_design</span>,</span>
<span>  variance_estimator <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span>
<span>    <span class="st">"Phase 1"</span> <span class="op">=</span> <span class="st">"Stratified Multistage SRS"</span>,</span>
<span>    <span class="st">"Phase 2"</span> <span class="op">=</span> <span class="st">"Ultimate Cluster"</span></span>
<span>  <span class="op">)</span>,</span>
<span>  max_replicates <span class="op">=</span> <span class="fl">500</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Warning in as_fays_gen_rep_design.twophase2(design = twophase_design,</span></span>
<span><span class="co">#&gt; variance_estimator = list(`Phase 1` = "Stratified Multistage SRS", : The sample</span></span>
<span><span class="co">#&gt; quadratic form matrix for this design and variance estimator is not positive</span></span>
<span><span class="co">#&gt; semidefinite. It will be approximated by the nearest positive semidefinite</span></span>
<span><span class="co">#&gt; matrix.</span></span></code></pre></div>
<p>The key difference from a programming standpoint is that we use the
argument <code>max_replicates</code> to specify the maximum number of
replicates that can be created. If the function determines that fewer
than <code>max_replicates</code> are needed to obtain a fully-efficient
variance estimator, then the actual number of replicates created will be
less than <code>max_replicates</code>.</p>
</div>
<div class="section level3">
<h3 id="calibrating-second-phase-weights-to-first-phase-estimates">Calibrating Second-phase Weights to First-phase Estimates<a class="anchor" aria-label="anchor" href="#calibrating-second-phase-weights-to-first-phase-estimates"></a>
</h3>
<p>In two-phase sampling, it can be helpful to calibrate the weights
from the small second-phase sample using estimates produced from the
larger, more reliable first-phase sample. The main reason for doing this
is to produce more precise estimates for variables only measured in the
second-phase sample, and calibration is effective at this if the
calibration variables are associated with the second-phase variables of
interest. But calibration is also nice because it forces second-phase
estimates for calibration variables to match the first-phase estimates,
thus improving the consistency of the two sets of estimates.</p>
<p>Calibrating the weights for the second-phase sample is
straightforward and can be done using usual software and methods.
However, care is needed to ensure that resulting variance estimates
appropriately reflect the fact that we are calibrating to
<em>estimates</em> rather than to known population values. This is
fairly easy when replication methods are used for variance estimation,
but requires the use of the appropriate functions from the ‘svrep’
package. Section 4.3.1 of this memo discusses the theory of replicate
variance estimation for two-phase calibration, based on more detailed
treatments of this topic by <span class="citation">Fuller (1998)</span>
and <span class="citation">Lohr (2022)</span>.</p>
<p>Below is a general process for using the ‘svrep’ package to calibrate
a second-phase sample to first-phase estimates while ensuring that
replicate weights are adjusted appropriately for the purpose of variance
estimation. There are two useful functions from the ‘svrep’ package for
this purpose, which we present as “Option 1” and “Option 2” in the
following overview.</p>
<div class="section level4">
<h4 id="preliminaries">Preliminaries<a class="anchor" aria-label="anchor" href="#preliminaries"></a>
</h4>
<p><strong>Ensure that the calibration variables do not have any missing
values</strong></p>
<p>First, we need to ensure that the variables we want to use for
calibration do not have any missing values in either the first-phase or
second-phase sample. Some imputation might be necessary.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Impute missing values (if necessary)</span></span>
<span><span class="va">twophase_sample</span> <span class="op">&lt;-</span> <span class="va">twophase_sample</span> <span class="op">|&gt;</span></span>
<span>  <span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html" class="external-link">mutate</a></span><span class="op">(</span></span>
<span>    TOTCIR <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html" class="external-link">ifelse</a></span><span class="op">(</span></span>
<span>      <span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">TOTCIR</span><span class="op">)</span>,</span>
<span>      <span class="fu">stats</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/stats/weighted.mean.html" class="external-link">weighted.mean</a></span><span class="op">(</span><span class="va">TOTCIR</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>                           w <span class="op">=</span> <span class="fl">1</span><span class="op">/</span><span class="va">SAMPLING_PROB</span><span class="op">)</span>,</span>
<span>      <span class="va">TOTCIR</span></span>
<span>    <span class="op">)</span>,</span>
<span>    TOTSTAFF <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html" class="external-link">ifelse</a></span><span class="op">(</span></span>
<span>      <span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">TOTSTAFF</span><span class="op">)</span>,</span>
<span>      <span class="fu">stats</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/stats/weighted.mean.html" class="external-link">weighted.mean</a></span><span class="op">(</span><span class="va">TOTSTAFF</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>                           w <span class="op">=</span> <span class="fl">1</span><span class="op">/</span><span class="va">SAMPLING_PROB</span><span class="op">)</span>,</span>
<span>      <span class="va">TOTSTAFF</span></span>
<span>    <span class="op">)</span></span>
<span>  <span class="op">)</span></span></code></pre></div>
<p><strong>(If you haven’t already) Create replicate weights for the
second-phase sample</strong></p>
<p>Before calibration, we need to create replicate weights for the
second-phase sample that appropriately reflect the sampling variance of
the entire two-phase design. We did that already in this document, but
we’ll repeat that code again below.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Describe the two-phase survey design</span></span>
<span>  <span class="va">twophase_design</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survey/man/twophase.html" class="external-link">twophase</a></span><span class="op">(</span></span>
<span>    method <span class="op">=</span> <span class="st">"full"</span>,</span>
<span>    data <span class="op">=</span> <span class="va">twophase_sample</span>,</span>
<span>    <span class="co"># Identify the subset of first-phase elements</span></span>
<span>    <span class="co"># which were selected into the second-phase sample</span></span>
<span>    subset <span class="op">=</span> <span class="op">~</span> <span class="va">SECOND_PHASE_SELECTION</span>,</span>
<span>    <span class="co"># Describe clusters, probabilities, and population sizes</span></span>
<span>    <span class="co"># at each phase of sampling</span></span>
<span>    id <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">~</span> <span class="va">PSU_ID</span> <span class="op">+</span> <span class="va">SSU_ID</span>,</span>
<span>              <span class="op">~</span> <span class="fl">1</span><span class="op">)</span>,</span>
<span>    probs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">~</span> <span class="va">PSU_SAMPLING_PROB</span> <span class="op">+</span> <span class="va">SSU_SAMPLING_PROB</span>,</span>
<span>                 <span class="cn">NULL</span><span class="op">)</span>,</span>
<span>    fpc <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">~</span> <span class="va">PSU_POP_SIZE</span> <span class="op">+</span> <span class="va">SSU_POP_SIZE</span>,</span>
<span>               <span class="cn">NULL</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span></span>
<span><span class="co"># Create replicate weights for the second-phase sample</span></span>
<span><span class="co"># (meant to reflect variance of the entire two-phase design)</span></span>
<span>  <span class="va">twophase_boot_design</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/as_gen_boot_design.html">as_gen_boot_design</a></span><span class="op">(</span></span>
<span>    design <span class="op">=</span> <span class="va">twophase_design</span>,</span>
<span>    variance_estimator <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span>
<span>      <span class="st">"Phase 1"</span> <span class="op">=</span> <span class="st">"Stratified Multistage SRS"</span>,</span>
<span>      <span class="st">"Phase 2"</span> <span class="op">=</span> <span class="st">"Ultimate Cluster"</span></span>
<span>    <span class="op">)</span>,</span>
<span>    replicates <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>    mse <span class="op">=</span> <span class="cn">TRUE</span></span>
<span>  <span class="op">)</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="option-1-calibrate-to-a-set-of-estimates-and-their-variance-covariance-matrix">Option 1: Calibrate to a set of estimates and their
variance-covariance matrix<a class="anchor" aria-label="anchor" href="#option-1-calibrate-to-a-set-of-estimates-and-their-variance-covariance-matrix"></a>
</h4>
<p>In this approach, we use data from the first-phase sample to produce
estimated totals to use for calibration of the second-phase sample. To
ensure that the calibration of the second-phase sample appropriately
reflects the variance of the first-phase estimated totals, we also need
to estimate the variance of the first-phase totals.</p>
<p>There are many ways to estimate the first-phase variance, but for
convenience we’ll use the generalized bootstrap.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Extract a survey design object representing the first phase sample</span></span>
<span>  <span class="va">first_phase_design</span> <span class="op">&lt;-</span> <span class="va">twophase_design</span><span class="op">$</span><span class="va">phase1</span><span class="op">$</span><span class="va">full</span></span>
<span></span>
<span><span class="co"># Create replicate weights for the first-phase sample</span></span>
<span>  <span class="va">first_phase_gen_boot</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/as_gen_boot_design.html">as_gen_boot_design</a></span><span class="op">(</span></span>
<span>    design <span class="op">=</span> <span class="va">first_phase_design</span>,</span>
<span>    variance_estimator <span class="op">=</span> <span class="st">"Stratified Multistage SRS"</span>,</span>
<span>    replicates <span class="op">=</span> <span class="fl">1000</span></span>
<span>  <span class="op">)</span></span>
<span>  </span>
<span><span class="co"># Estimate first-phase totals and their sampling-covariance</span></span>
<span>  <span class="va">first_phase_estimates</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survey/man/surveysummary.html" class="external-link">svytotal</a></span><span class="op">(</span></span>
<span>    x <span class="op">=</span> <span class="op">~</span> <span class="va">TOTCIR</span> <span class="op">+</span> <span class="va">TOTSTAFF</span>,</span>
<span>    design <span class="op">=</span> <span class="va">first_phase_gen_boot</span></span>
<span>  <span class="op">)</span></span>
<span>  </span>
<span>  <span class="va">first_phase_totals</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="va">first_phase_estimates</span><span class="op">)</span></span>
<span>  <span class="va">first_phase_vcov</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/vcov.html" class="external-link">vcov</a></span><span class="op">(</span><span class="va">first_phase_estimates</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">first_phase_totals</span><span class="op">)</span></span>
<span><span class="co">#&gt;       TOTCIR     TOTSTAFF </span></span>
<span><span class="co">#&gt; 1648795905.4     152846.6</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">first_phase_vcov</span><span class="op">)</span></span>
<span><span class="co">#&gt;                TOTCIR     TOTSTAFF</span></span>
<span><span class="co">#&gt; TOTCIR   6.606150e+16 5.853993e+12</span></span>
<span><span class="co">#&gt; TOTSTAFF 5.853993e+12 5.747174e+08</span></span>
<span><span class="co">#&gt; attr(,"means")</span></span>
<span><span class="co">#&gt; [1] 1648121469.6     152702.4</span></span></code></pre></div>
<p>After we’ve estimated the first-phase totals, we can use the function
<code><a href="../reference/calibrate_to_estimate.html">calibrate_to_estimate()</a></code> to calibrate the two-phase survey
design object to the first-phase totals. This function is discussed in
more detail in the vignette titled “Sample-based Calibration”, and the
underlying method is described in <span class="citation">Fuller
(1998)</span>.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">calibrated_twophase_design</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/calibrate_to_estimate.html">calibrate_to_estimate</a></span><span class="op">(</span></span>
<span>  rep_design <span class="op">=</span> <span class="va">twophase_boot_design</span>,</span>
<span>  <span class="co"># Specify the variables in the data to use for calibration</span></span>
<span>  cal_formula <span class="op">=</span> <span class="op">~</span> <span class="va">TOTCIR</span> <span class="op">+</span> <span class="va">TOTSTAFF</span>,</span>
<span>  <span class="co"># Supply the first-phase estimates and their variance</span></span>
<span>  estimate <span class="op">=</span> <span class="va">first_phase_totals</span>,</span>
<span>  vcov_estimate <span class="op">=</span> <span class="va">first_phase_vcov</span>,</span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Selection of replicate columns whose control totals will be perturbed will be done at random.</span></span>
<span><span class="co">#&gt; For tips on reproducible selection, see `help('calibrate_to_estimate')`</span></span></code></pre></div>
<p>Let’s examine the results from calibration. First, we’ll check that
the calibrated second-phase estimates match the first-phase
estimates.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Display second-phase estimates for calibration variables</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/survey/man/surveysummary.html" class="external-link">svytotal</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="op">~</span> <span class="va">TOTCIR</span> <span class="op">+</span> <span class="va">TOTSTAFF</span>,</span>
<span>  design <span class="op">=</span> <span class="va">calibrated_twophase_design</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt;               total        SE</span></span>
<span><span class="co">#&gt; TOTCIR   1648795905 257024311</span></span>
<span><span class="co">#&gt; TOTSTAFF     152847     23973</span></span>
<span></span>
<span><span class="co"># Display the original first-phase estimates (which are identical!)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">first_phase_estimates</span><span class="op">)</span></span>
<span><span class="co">#&gt;               total        SE</span></span>
<span><span class="co">#&gt; TOTCIR   1648795905 257024311</span></span>
<span><span class="co">#&gt; TOTSTAFF     152847     23973</span></span></code></pre></div>
<p>Next, we’ll inspect an estimate for a variable that wasn’t used in
calibration.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Inspect calibrated second-phase estimate</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/survey/man/surveysummary.html" class="external-link">svytotal</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="op">~</span> <span class="va">LIBRARIA</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  design <span class="op">=</span> <span class="va">calibrated_twophase_design</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt;          total    SE</span></span>
<span><span class="co">#&gt; LIBRARIA 57355 12308</span></span>
<span></span>
<span><span class="co"># Compare to uncalibrated second-phase estimate</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/survey/man/surveysummary.html" class="external-link">svytotal</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="op">~</span> <span class="va">LIBRARIA</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  design <span class="op">=</span> <span class="va">twophase_boot_design</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt;          total    SE</span></span>
<span><span class="co">#&gt; LIBRARIA 54368 12039</span></span>
<span></span>
<span><span class="co"># Compare to first-phase estimate</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/survey/man/surveysummary.html" class="external-link">svytotal</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="op">~</span> <span class="va">LIBRARIA</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  design <span class="op">=</span> <span class="va">first_phase_gen_boot</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt;          total     SE</span></span>
<span><span class="co">#&gt; LIBRARIA 55696 9171.3</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="option-2-calibrate-to-independently-generated-first-phase-replicates">Option 2: Calibrate to independently-generated first-phase
replicates<a class="anchor" aria-label="anchor" href="#option-2-calibrate-to-independently-generated-first-phase-replicates"></a>
</h4>
<p>If we have the data for the first-phase sample available and there
are replicate weights created for the first-phase sample, then we have
an arguably better method available to handle calibration. We can simply
produce replicate estimates of the first-phase totals using each
first-phase replicate, and then we can calibrate each second-phase
replicate to one of the first-phase replicate totals.</p>
<p>To do this, we first create replicate weights for the first-phase
design using the generalized bootstrap (or any other replication
method).</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Extract a survey design object representing the first phase sample</span></span>
<span>  <span class="va">first_phase_design</span> <span class="op">&lt;-</span> <span class="va">twophase_design</span><span class="op">$</span><span class="va">phase1</span><span class="op">$</span><span class="va">full</span></span>
<span></span>
<span><span class="co"># Create replicate weights for the first-phase sample</span></span>
<span>  <span class="va">first_phase_gen_boot</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/as_gen_boot_design.html">as_gen_boot_design</a></span><span class="op">(</span></span>
<span>    design <span class="op">=</span> <span class="va">first_phase_design</span>,</span>
<span>    variance_estimator <span class="op">=</span> <span class="st">"Stratified Multistage SRS"</span>,</span>
<span>    replicates <span class="op">=</span> <span class="fl">1000</span></span>
<span>  <span class="op">)</span></span></code></pre></div>
<p>After we’ve created the first-phase replicates, we can use the
function <code><a href="../reference/calibrate_to_sample.html">calibrate_to_sample()</a></code> to calibrate the two-phase
survey design object to replicate estimates created using the
first-phase replicate design. This function is discussed in more detail
in the vignette titled “Sample-based Calibration”. See Section 4.3.1 of
this vignette for the underlying theory, which is based on <span class="citation">Fuller (1998)</span> and <span class="citation">Opsomer
and Erciulescu (2021)</span>.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;This method is justified by the arguments made in &lt;span class="citation"&gt;Fuller (1998)&lt;/span&gt;, although the idea of using one
sample’s replicate estimates as control totals for another survey’s
replicate estimates appears to have first been proposed by &lt;span class="citation"&gt;Opsomer and Erciulescu (2021)&lt;/span&gt;, in the context of
two independent samples.&lt;/p&gt;'><sup>1</sup></a></p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">calibrated_twophase_design</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/calibrate_to_sample.html">calibrate_to_sample</a></span><span class="op">(</span></span>
<span>  primary_rep_design <span class="op">=</span> <span class="va">twophase_boot_design</span>,</span>
<span>  <span class="co"># Supply the first-phase replicate design</span></span>
<span>  control_rep_design <span class="op">=</span> <span class="va">first_phase_gen_boot</span>,</span>
<span>  <span class="co"># Specify the variables in the data to use for calibration</span></span>
<span>  cal_formula <span class="op">=</span> <span class="op">~</span> <span class="va">TOTCIR</span> <span class="op">+</span> <span class="va">TOTSTAFF</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Matching between primary and control replicates will be done at random.</span></span>
<span><span class="co">#&gt; For tips on reproducible matching, see `help('calibrate_to_sample')`</span></span></code></pre></div>
<p>Let’s examine the results from calibration. First, we’ll check that
the calibrated second-phase estimates match the first-phase
estimates.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Display second-phase estimates for calibration variables</span></span>
<span><span class="va">calibrated_ests</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survey/man/surveysummary.html" class="external-link">svytotal</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="op">~</span> <span class="va">TOTCIR</span> <span class="op">+</span> <span class="va">TOTSTAFF</span>,</span>
<span>  design <span class="op">=</span> <span class="va">calibrated_twophase_design</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">calibrated_ests</span><span class="op">)</span></span>
<span><span class="co">#&gt;               total        SE</span></span>
<span><span class="co">#&gt; TOTCIR   1648795905 242527993</span></span>
<span><span class="co">#&gt; TOTSTAFF     152847     22856</span></span>
<span></span>
<span><span class="co"># Display the original first-phase estimates (which are identical!)</span></span>
<span><span class="va">first_phase_ests</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survey/man/surveysummary.html" class="external-link">svytotal</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="op">~</span> <span class="va">TOTCIR</span> <span class="op">+</span> <span class="va">TOTSTAFF</span>,</span>
<span>  design <span class="op">=</span> <span class="va">first_phase_gen_boot</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">first_phase_ests</span><span class="op">)</span></span>
<span><span class="co">#&gt;               total        SE</span></span>
<span><span class="co">#&gt; TOTCIR   1648795905 242515035</span></span>
<span><span class="co">#&gt; TOTSTAFF     152847     22854</span></span></code></pre></div>
<p>As expected, the variance estimate for the calibrated second-phase
estimate is the same as the variance estimate for the first-phase
estimate, allowing a small tolerance for numeric differences.</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ratio_of_variances</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/vcov.html" class="external-link">vcov</a></span><span class="op">(</span><span class="va">calibrated_ests</span><span class="op">)</span><span class="op">/</span><span class="fu"><a href="https://rdrr.io/r/stats/vcov.html" class="external-link">vcov</a></span><span class="op">(</span><span class="va">first_phase_ests</span><span class="op">)</span></span>
<span><span class="va">ratio_of_variances</span></span>
<span><span class="co">#&gt;             TOTCIR  TOTSTAFF</span></span>
<span><span class="co">#&gt; TOTCIR   1.0001069 0.9998445</span></span>
<span><span class="co">#&gt; TOTSTAFF 0.9998445 1.0002008</span></span>
<span><span class="co">#&gt; attr(,"means")</span></span>
<span><span class="co">#&gt;       TOTCIR     TOTSTAFF </span></span>
<span><span class="co">#&gt; 1648795905.4     152846.6</span></span></code></pre></div>
<p>Next, we’ll inspect an estimate for a variable that wasn’t used in
calibration.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Inspect calibrated second-phase estimate</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/survey/man/surveysummary.html" class="external-link">svytotal</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="op">~</span> <span class="va">LIBRARIA</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  design <span class="op">=</span> <span class="va">calibrated_twophase_design</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt;          total    SE</span></span>
<span><span class="co">#&gt; LIBRARIA 57355 11958</span></span>
<span></span>
<span><span class="co"># Compare to uncalibrated second-phase estimate</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/survey/man/surveysummary.html" class="external-link">svytotal</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="op">~</span> <span class="va">LIBRARIA</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  design <span class="op">=</span> <span class="va">twophase_boot_design</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt;          total    SE</span></span>
<span><span class="co">#&gt; LIBRARIA 54368 12039</span></span>
<span></span>
<span><span class="co"># Compare to first-phase estimate</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/survey/man/surveysummary.html" class="external-link">svytotal</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="op">~</span> <span class="va">LIBRARIA</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  design <span class="op">=</span> <span class="va">first_phase_gen_boot</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt;          total     SE</span></span>
<span><span class="co">#&gt; LIBRARIA 55696 8876.4</span></span></code></pre></div>
</div>
</div>
<div class="section level3">
<h3 id="ratio-estimation">Ratio Estimation<a class="anchor" aria-label="anchor" href="#ratio-estimation"></a>
</h3>
<p>A special case of calibration that is commonly used in two-phase
samples is ratio estimation. Whether you use the function
<code><a href="../reference/calibrate_to_sample.html">calibrate_to_sample()</a></code> or
<code><a href="../reference/calibrate_to_estimate.html">calibrate_to_estimate()</a></code>, the syntax is very similar.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ratio_calib_design</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/calibrate_to_sample.html">calibrate_to_sample</a></span><span class="op">(</span></span>
<span>  primary_rep_design <span class="op">=</span> <span class="va">twophase_boot_design</span>,</span>
<span>  <span class="co"># Supply the first-phase replicate design</span></span>
<span>  control_rep_design <span class="op">=</span> <span class="va">first_phase_gen_boot</span>,</span>
<span>  <span class="co"># Specify the GREG formula.</span></span>
<span>  <span class="co"># For ratio estimation, we add `-1` to the formula </span></span>
<span>  <span class="co"># (i.e., we remove the intercept from the working model)</span></span>
<span>  <span class="co"># and specify only a single variable</span></span>
<span>  cal_formula <span class="op">=</span> <span class="op">~</span> <span class="op">-</span><span class="fl">1</span> <span class="op">+</span> <span class="va">TOTSTAFF</span>,</span>
<span>  variance <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Matching between primary and control replicates will be done at random.</span></span>
<span><span class="co">#&gt; For tips on reproducible matching, see `help('calibrate_to_sample')`</span></span></code></pre></div>
<p>Note that for ratio estimation, the calibration formula includes
<code>-1</code> to ensure that ratio estimation is used instead of
regression estimation. This is similar to how, when fitting a regression
model in R, we use <code>lm(y ~ -1 + x)</code> to fit a linear model
without an intercept. Specifying the parameter <code>variance = 1</code>
indicates that the working model used in calibration is homoskedastic,
and so the same adjustment factor will be used for every case’s weights.
This can be seen when we compare the adjusted weights to the unadjusted
weights.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">ratio_adjusted_weights</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/weights.html" class="external-link">weights</a></span><span class="op">(</span><span class="va">ratio_calib_design</span>, type <span class="op">=</span> <span class="st">"sampling"</span><span class="op">)</span></span>
<span><span class="va">unadjusted_weights</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/weights.html" class="external-link">weights</a></span><span class="op">(</span><span class="va">twophase_boot_design</span>, type <span class="op">=</span> <span class="st">"sampling"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">adjustment_factors</span> <span class="op">&lt;-</span> <span class="va">ratio_adjusted_weights</span><span class="op">/</span><span class="va">unadjusted_weights</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">adjustment_factors</span><span class="op">)</span></span>
<span><span class="co">#&gt;        1        3        5        7       10       13 </span></span>
<span><span class="co">#&gt; 1.090189 1.090189 1.090189 1.090189 1.090189 1.090189</span></span></code></pre></div>
<p>Note that the adjustment factor for the weights is simply the ratio
of the first-phase estimated total to the second-phase estimated
total.</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">phase1_total</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survey/man/surveysummary.html" class="external-link">svytotal</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="op">~</span> <span class="va">TOTSTAFF</span>,</span>
<span>  <span class="va">first_phase_design</span></span>
<span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="va">phase2_total</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/survey/man/surveysummary.html" class="external-link">svytotal</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="op">~</span> <span class="va">TOTSTAFF</span>,</span>
<span>  <span class="va">twophase_boot_design</span></span>
<span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/stats/coef.html" class="external-link">coef</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="va">phase1_total</span><span class="op">/</span><span class="va">phase2_total</span></span>
<span><span class="co">#&gt; TOTSTAFF </span></span>
<span><span class="co">#&gt; 1.090189</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="design-based-estimators-for-two-phase-sampling">Design-based Estimators for Two-phase Sampling<a class="anchor" aria-label="anchor" href="#design-based-estimators-for-two-phase-sampling"></a>
</h2>
<p>In the section below, we first describe the double expansion
estimator (DEE) which produces unbiased estimates for two-phase samples,
using only information about the sampling design in both phases. Next,
we describe calibration estimators which adjust the weights from the
double-expansion estimator so that sampling variances can be reduced
using information from the first-phase sample. We’ll examine both the
theoretical sampling variance of each estimator as well as approaches
for estimating variance using replication methods.</p>
<p>The interested reader is encouraged to consult chapter 9.3 of <span class="citation">Särndal, Swensson, and Wretman (1992)</span> or chapter
12 of <span class="citation">Lohr (2022)</span> for a more detailed
discussion of two-phase sampling.</p>
<div class="section level3">
<h3 id="notation">Notation<a class="anchor" aria-label="anchor" href="#notation"></a>
</h3>
<p>We use the following notation to denote each sample and its size.</p>
<div class="section level4">
<h4 id="notation-for-samples-and-sample-size">Notation for Samples and Sample Size<a class="anchor" aria-label="anchor" href="#notation-for-samples-and-sample-size"></a>
</h4>
<p><span class="math display">\[
\begin{aligned}
s_a &amp;: \text{The set of units in the first-phase sample} \\
s_b &amp;: \text{The set of units in the second-phase sample} \\
&amp; \space \space \space \text{Note that }s_b \text{ is a subset of }
s_a \\
n_a &amp;: \text{The number of units in }s_1 \\
n_b &amp;: \text{The number of units in }s_2 \\
\end{aligned}
\]</span></p>
</div>
<div class="section level4">
<h4 id="notation-for-probabilities-and-weights">Notation for Probabilities and Weights<a class="anchor" aria-label="anchor" href="#notation-for-probabilities-and-weights"></a>
</h4>
<p>We use the following notation to denote the <strong>inclusion
probability</strong> of each unit, for each phase:</p>
<p><span class="math display">\[
\begin{aligned}
\pi^{(a)}_{i} &amp;: \text{The probability unit }i \text{ is included in
} s_a \\
\pi^{(b|s_a)}_{i} &amp;: \text{The conditional probability unit }i
\text{ is included in } s_b, \\
&amp; \text{ given the realized first-phase sample }s_a \\
\pi_i &amp;: \text{The } \textbf{unconditional} \text{ probability unit
}i \text{ is included in }s_b \\
\end{aligned}
\]</span></p>
<p>In practice, the probability <span class="math inline">\(\pi_i\)</span> is prohibitively difficult to
calculate, because it requires us to figure out <span class="math inline">\(\pi^{(b|s_a)}_{i}\)</span> for every possible
first-phase sample <span class="math inline">\(s_a\)</span>, not just
the particular <span class="math inline">\(s_a\)</span> that we actually
selected. So instead, we define the useful quantity <span class="math inline">\(\pi^{*}\)</span>, which depends only on the
particular first-phase sample <span class="math inline">\(s_a\)</span>
that we actually selected.</p>
<p><span class="math display">\[
\pi_i^{*} := \pi^{(b|s_a)}_{i} \times \pi^{(a)}_{i}
\]</span></p>
<p>For variance estimation, it’s also necessary to consider the
<strong>joint inclusion probability</strong> (sometimes referred to as
“second order probability”), which is simply the probability that a pair
of units <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> are both included in a sample.</p>
<p><span class="math display">\[
\begin{aligned}
\pi^{(a)}_{ij} &amp;: \text{The probability units }i \text{ and } j
\text{ are both included in } s_a \\
\pi^{(b|s_a)}_{ij} &amp;: \text{The conditional probability units }i
\text{ and } j \text{ are both included in } s_b, \\
&amp; \text{ given the realized first-phase sample }s_a \\
\end{aligned}
\]</span></p>
<p>We also define the quantity <span class="math inline">\(\pi^{*}_{ij}\)</span> similar to <span class="math inline">\(\pi^{*}_i\)</span>.</p>
<p><span class="math display">\[
\pi_{ij}^{*} := \pi^{(b|s_a)}_{ij} \times \pi^{(a)}_{ij}
\]</span></p>
<p>The probabilities and the <span class="math inline">\(\pi_{i}^{*}\)</span> values are used to define
sampling weights for the survey.</p>
<p><span class="math display">\[
\begin{aligned}
w^{(a)}_i &amp;:= 1/\pi^{(a)}_i \\
w^{(b|s_a)}_i &amp;:= 1/\pi^{(b|s_a)}_{i} \\
w^{*}_i &amp;:= 1/\pi^{*}_i = w^{(b|s_a)}_i \times w^{(a)}_i
\end{aligned}
\]</span></p>
</div>
</div>
<div class="section level3">
<h3 id="the-double-expansion-estimator">The Double Expansion Estimator<a class="anchor" aria-label="anchor" href="#the-double-expansion-estimator"></a>
</h3>
<p>Suppose we wish to estimate a population total <span class="math inline">\(Y\)</span>, using observed values <span class="math inline">\(y_i\)</span> in our second-phase sample, <span class="math inline">\(s_b\)</span>. <span class="citation">Särndal,
Swensson, and Wretman (1992)</span> show that we can produce an unbiased
estimate of <span class="math inline">\(Y\)</span> using the
second-phase sample <span class="math inline">\(s_b\)</span>, as
follows:</p>
<p><span class="math display">\[
\begin{aligned}
\hat{Y}^{(b)} &amp;= \sum_{i=1}^{n_{(b)}} w^{*}_i \times y_i  \\
&amp;= \sum_{i=1}^{n_{(b)}} w^{(b|s_a)}_i \times w^{(a)}_i \times y_i
\end{aligned}
\]</span></p>
<p>This estimator has been dubbed the “double expansion estimator”,
using the sampling jargon that refers to weighting a sample value <span class="math inline">\(y_i\)</span> as “expanding” <span class="math inline">\(y_i\)</span> from the sample to the population.
The name “double expansion” is used because the weight <span class="math inline">\(w^{*}_i\)</span> can be thought of as first using
the weight <span class="math inline">\(w^{(b|s_a)}_i\)</span> to
“expand” the quantity <span class="math inline">\(y_i\)</span> and then
using the weight <span class="math inline">\(w^{(a)}_i\)</span> to
expand the quantity <span class="math inline">\(w^{(b|s_a)}_i \times
y_i\)</span>.</p>
<div class="section level4">
<h4 id="variance-of-the-double-expansion-estimator">Variance of the Double Expansion Estimator<a class="anchor" aria-label="anchor" href="#variance-of-the-double-expansion-estimator"></a>
</h4>
<p>The sampling variance of the double expansion estimator is the sum of
two different components.</p>
<p><span class="math display">\[
\begin{aligned}
V\left(\hat{Y}^{(b)}\right) &amp;=
V\left(\hat{Y}^{(a)}\right)+E\left(V\left[\hat{Y}^{(b)} \mid s_a
\right]\right) \\
\\
\text{where: }&amp; \hat{Y}^{(a)} = \sum_{i=1}^{n_{(a)}} w^{(a)}_i
\times y_i \\
\text{and }&amp; V\left[\hat{Y}^{(b)} \mid s_a \right] \text{ is the
variance of } \hat{Y}^{(b)} \\
&amp;\text{ across all samples } s_b \\
&amp;\text{ drawn from a given } s_a
\end{aligned}
\]</span></p>
<p>The first component is the variance of the estimate <span class="math inline">\(\hat{Y}^{(a)}\)</span> that we would obtain if we
used the entire first-phase sample <span class="math inline">\(s_a\)</span> for our estimate, rather than using
the subset <span class="math inline">\(s_b\)</span>.</p>
<p>The second component is the additional variance caused by using the
subset <span class="math inline">\(s_b\)</span> instead of <span class="math inline">\(s_a\)</span>. It is equal to the expected value
(across all samples <span class="math inline">\(s_a\)</span>) of the
conditional variance of <span class="math inline">\(\hat{Y}^{(b)}\)</span> across all samples <span class="math inline">\(s_b\)</span> (conditioning on a given first-phase
sample <span class="math inline">\(s_a\)</span>).</p>
<div class="section level5">
<h5 id="estimating-the-variance-of-the-double-expansion-estimator">Estimating the Variance of the Double Expansion Estimator<a class="anchor" aria-label="anchor" href="#estimating-the-variance-of-the-double-expansion-estimator"></a>
</h5>
<p>Both variance components can be estimated using only the values <span class="math inline">\(y_i\)</span> observed in <span class="math inline">\(s_b\)</span>. For the second component, we simply
estimate <span class="math inline">\(V\left[\hat{Y}^{(b)} \mid s_a
\right]\)</span>, which is an unbiased estimate for its expectation,
<span class="math inline">\(E\left(V\left[\hat{Y}^{(b)} \mid s_a
\right]\right)\)</span>.</p>
<p>Thus, our variance estimate for the double expansion estimator takes
the following form:</p>
<p><span class="math display">\[
\hat{V}\left(\hat{Y}^{(b)}\right) = \hat{V}\left[\hat{Y}^{(a)} \right] +
\hat{V}\left[\hat{Y}^{(b)} \mid s_a \right]
\]</span></p>
<div class="section level6">
<h6 id="estimating-the-second-phase-variance-component">Estimating the second-phase variance component<a class="anchor" aria-label="anchor" href="#estimating-the-second-phase-variance-component"></a>
</h6>
<p>For estimating <span class="math inline">\(\hat{V}\left[\hat{Y}^{(b)}
\mid s_a \right]\)</span>, we simply choose a variance estimator for the
second-phase design, taking the first-phase sample as a given. We assume
that this variance estimator can be written as a quadratic form.</p>
<p><span class="math display">\[
\begin{aligned}
\hat{V}\left[\hat{Y}^{(b)} \mid s_a \right] &amp;= \sum_{i=1}^{n_b}
\sum_{i=1}^{n_b} \sigma^{(b)}_{ij} (w^{*}_i y_i) (w^{*}_j y_j) \\
\end{aligned}
\]</span></p>
<p>For the Horvitz-Thompson estimator, for instance, we would use <span class="math inline">\(\sigma^{(b)}_{ij}=\left(1 -
\frac{\pi^{b|s_a}_i\pi^{b|s_a}_j}{\pi^{b|s_a}_{ij}}\right)\)</span>.</p>
<p>This quadratic form can also be written in matrix notation:</p>
<p><span class="math display">\[
\begin{aligned}
\hat{V}\left[\hat{Y}^{(b)} \mid s_a \right] &amp;= {(W^{*} y)}^{\prime}
\Sigma_b {(W^{*} y)} \\
\text{where }&amp; \Sigma_b \text{ is an } n_b \times n_b \text{
symmetric matrix} \\
&amp; \text{ with entry } ij \text{ equal to } \sigma^{(b)}_{ij} \\
\text{and } &amp; W^{*} \text{ is the } n_b \times n_b \text{ diagonal
matrix} \\
&amp; \text{ with entry } ii \text{ equal to } w^{*}_i  \\
&amp; y \text{ is the } n_b \times 1 \text{ vector of values} \\
&amp; \text{for the variable of interest}
\end{aligned}
\]</span></p>
</div>
<div class="section level6">
<h6 id="estimating-the-first-phase-variance-component">Estimating the first-phase variance component<a class="anchor" aria-label="anchor" href="#estimating-the-first-phase-variance-component"></a>
</h6>
<p>Estimating the first variance component, <span class="math inline">\(V\left(\hat{Y}^{(a)}\right)\)</span>, is only
slightly trickier. First, we need to choose a variance estimator
appropriate to the first-phase design, which we would use if we had
<span class="math inline">\(y_i\)</span> observed for the entire sample
<span class="math inline">\(s_a\)</span>. We’ll denote that variance
estimator <span class="math inline">\(\tilde{V}\left[\hat{Y}^{(a)}\right]\)</span>.</p>
<p><span class="math display">\[
\begin{aligned}
\tilde{V}\left[\hat{Y}^{(a)} \right] &amp;= \sum_{i=1}^{n_a}
\sum_{i=1}^{n_a} \sigma^{(a)}_{ij} (w^{(a)}_i y_i) (w^{(a)}_i y_j) \\
\end{aligned}
\]</span></p>
<p>In matrix notation, we can write:</p>
<p><span class="math display">\[
\begin{aligned}
\tilde{V}\left[\hat{Y}^{(a)} \right] &amp;= {(W^{(a)} y)}^{\prime}
(\Sigma_{a} ) {(W^{(a)} y)} \\
\text{where }&amp; \Sigma_{a} \text{ is an } n_a \times n_a \text{
symmetric matrix} \\
&amp; \text{ with entry } ij \text{ equal to } \sigma_{ij} \\
\text{and } &amp; W^{(a)} \text{ is the } n_a \times n_a \text{ diagonal
matrix} \\
&amp; \text{ with entry } ii \text{ equal to } w^{(a)}_i
\end{aligned}
\]</span></p>
<p>However, since we’re working with the subsample <span class="math inline">\(s_b\)</span> instead of <span class="math inline">\(s_a\)</span>, we need to estimate <span class="math inline">\(\tilde{V}\left[\hat{Y}^{(a)} \right]\)</span>
using only the data from <span class="math inline">\(s_b\)</span>. We
can use the second-phase joint inclusion probabilities <span class="math inline">\(\pi^{(b \mid s_a)}_{ij}\)</span> to produce an
unbiased estimate of <span class="math inline">\(\tilde{V}\left[\hat{Y}^{(a)} \right]\)</span>
using only the data from <span class="math inline">\(s_b\)</span>.</p>
<p><span class="math display">\[
\begin{aligned}
\hat{V}\left[\hat{Y}^{(a)} \right] &amp;=  \sum_{i=1}^{n_b}
\sum_{i=1}^{n_b} \frac{1}{\pi^{(b \mid s_a)}_{ij}} \sigma^{(a)}_{ij}
(w^{(a)}_i y_i) (w^{(a)}_i y_j) \\
\end{aligned}
\]</span></p>
<p>We can also write this in matrix notation:</p>
<p><span class="math display">\[
\begin{aligned}
\hat{V}\left[\hat{Y}^{(a)} \right] &amp;= {(W^{(a)} y)}^{\prime}
(\Sigma_{a^{\prime}} \circ D_b ) {(W^{(a)} y)} \\
\text{where }&amp; \Sigma_{a^{\prime}} \text{ is an } n_b \times n_b
\text{ symmetric matrix} \\
&amp; \text{ with entry } ij \text{ equal to } \sigma_{ij} \\
\text{and } &amp; W^{(a)} \text{ is the } n_b \times n_b \text{ diagonal
matrix} \\
&amp; \text{ with entry } ii \text{ equal to } w^{(a)}_i
\\
\text{ and }&amp; D_b \text{ is an } n_b \times n_b \text{ symmetric
matrix} \\
&amp; \text{ with entry } ij \text{ equal to } \frac{1}{\pi^{(b \mid
s_a)}_{ij}}\\
\end{aligned}
\]</span></p>
<p>As a sidenote, that matrix <span class="math inline">\(D_b\)</span>
is very likely the source of any warning messages you’ll see about a
two-phase variance estimator not being positive semidefinite. <a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;When a two-phase variance estimator is not positive
semidefinite, the culprit is usually the matrix &lt;span class="math inline"&gt;\(D_b\)&lt;/span&gt;. The matrix &lt;span class="math inline"&gt;\(D_b\)&lt;/span&gt; is frequently not positive
semidefinite and as a result causes the whole quadratic form not to be
positive semidefinite. The matrices &lt;span class="math inline"&gt;\(\Sigma_{a}\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(\Sigma_{b}\)&lt;/span&gt; are positive semidefinite for
the usual single-phase variance estimators for most single-phase designs
in practice, and so &lt;span class="math inline"&gt;\(\Sigma_{a^{\prime}}\)&lt;/span&gt; is too (since it is a
principal submatrix of &lt;span class="math inline"&gt;\(\Sigma_{a}\)&lt;/span&gt;).
But when &lt;span class="math inline"&gt;\(D_b\)&lt;/span&gt; isn’t also positive
semidefinite, then &lt;span class="math inline"&gt;\((\Sigma_{a^{\prime}}
\circ D_b)\)&lt;/span&gt; generally won’t be either. For one simple example of
a &lt;span class="math inline"&gt;\(D_b\)&lt;/span&gt; which is not positive
semidefinite, consider a simple random sample without replacement of
size &lt;span class="math inline"&gt;\(n=2\)&lt;/span&gt; from a population of &lt;span class="math inline"&gt;\(N=4\)&lt;/span&gt;. The matrix &lt;span class="math inline"&gt;\(D_b= \bigl( \begin{smallmatrix}(1/2)^{-1} &amp;amp;
(1/6)^{-1} \\ (1/6)^{-1} &amp;amp; (1/2)^{-1} \end{smallmatrix}\bigr)
=\bigl( \begin{smallmatrix}2 &amp;amp; 6\\ 6 &amp;amp;
2\end{smallmatrix}\bigr)\)&lt;/span&gt; is not positive semidefinite, since it
has eigenvalues &lt;span class="math inline"&gt;\(8\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(-4\)&lt;/span&gt;.&lt;/p&gt;'><sup>2</sup></a></p>
</div>
<div class="section level6">
<h6 id="combining-the-two-estimated-variance-components">Combining the two estimated variance components<a class="anchor" aria-label="anchor" href="#combining-the-two-estimated-variance-components"></a>
</h6>
<p>Putting the two estimated variance components together, we thus
obtain the following unbiased variance estimator for the double
expansion estimator.</p>
<p><span class="math display">\[
\begin{aligned}
\hat{V}\left(\hat{Y}^{(b)}\right) &amp;=
\hat{V}\left(\hat{Y}^{(a)}\right)+\hat{V}\left[\hat{Y}^{(b)} \mid s_a
\right] \\
&amp;= \sum_{i=1}^{n_b} \sum_{i=1}^{n_b} \frac{1}{\pi^{(b \mid
s_a)}_{ij}} \sigma^{(a)}_{ij} (w^{(a)}_i y_i) (w^{(a)}_i y_j) \\
&amp;+ \sum_{i=1}^{n_b} \sum_{i=1}^{n_b} \sigma^{(b)}_{ij} (w^{*}_i y_i)
(w^{*}_j y_j) \\
\end{aligned}
\]</span></p>
<p>In matrix notation, we can write this as follows:</p>
<p><span class="math display">\[
\begin{aligned}
\hat{V}\left(\hat{Y}^{(b)}\right) &amp;=
\hat{V}\left(\hat{Y}^{(a)}\right)+\hat{V}\left[\hat{Y}^{(b)} \mid s_a
\right] \\
&amp;= {(W^{(a)} y)}^{\prime} (\Sigma_{a^{\prime}} \circ D_b ) {(W^{(a)}
y)} \\
&amp;+ {(W^{*} y)}^{\prime} \Sigma_b {(W^{*} y)} \\
\end{aligned}
\]</span></p>
<p>Because quadratic forms are additive and because <span class="math inline">\(W^{*}=W^{(a)}W^{(b \mid s_a)}\)</span>, we can
more compactly write the estimator as follows:</p>
<p><span class="math display">\[
\begin{aligned}
\hat{V}\left(\hat{Y}^{(b)}\right) &amp;= (W^{*}y)^{\prime} \Sigma_{ab}
(W^{*}y) \\
\text{where } &amp; \\
\Sigma_{ab} &amp;=  {W^{(b)}}^{-1} (\Sigma_{a^{\prime}} \circ D_b )
{W^{(b)}}^{-1} + \Sigma_b \\
\text{where } &amp; W^{(b)} \text{ is the } n_b \times n_b \text{
diagonal matrix} \\
&amp; \text{ with entry } ii \text{ equal to } w^{(b \mid s_a)}_i
\end{aligned}
\]</span></p>
<p>In the ‘svrep’ package, <span class="math inline">\(\Sigma_{ab}\)</span> can be constructed with the
inputs <span class="math inline">\(\Sigma_{a^{\prime}}\)</span>, <span class="math inline">\(\Sigma_b\)</span>, and <span class="math inline">\((1/D_b)\)</span>, using the function
<code><a href="../reference/make_twophase_quad_form.html">make_twophase_quad_form()</a></code>.</p>
<details><summary>
Click to show/hide example of using
<code>make_twophase_quad_form()</code>
</summary><div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">2022</span><span class="op">)</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">100</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Select first phase sample, SRS without replacement</span></span>
<span>  <span class="va">phase_1_sample_indicators</span> <span class="op">&lt;-</span> <span class="fu">sampling</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sampling/man/srswor.html" class="external-link">srswor</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">50</span>, N <span class="op">=</span> <span class="fl">100</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/logical.html" class="external-link">as.logical</a></span><span class="op">(</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="va">phase_1_sample</span> <span class="op">&lt;-</span> <span class="va">y</span><span class="op">[</span><span class="va">phase_1_sample_indicators</span><span class="op">]</span></span>
<span>  </span>
<span><span class="co"># Make variance estimator for first-phase variance component</span></span>
<span>  <span class="va">Sigma_a</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/make_quad_form_matrix.html">make_quad_form_matrix</a></span><span class="op">(</span></span>
<span>    variance_estimator <span class="op">=</span> <span class="st">"Ultimate Cluster"</span>,</span>
<span>    cluster_ids <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">50</span><span class="op">)</span>,</span>
<span>    strata_ids <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>, times <span class="op">=</span> <span class="fl">50</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>    strata_pop_sizes <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">100</span>, times <span class="op">=</span> <span class="fl">50</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span></span>
<span><span class="co"># Select second stage sample, SRS without replacment</span></span>
<span>  <span class="va">phase_2_sample_indicators</span> <span class="op">&lt;-</span> <span class="fu">sampling</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/sampling/man/srswor.html" class="external-link">srswor</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fl">5</span>, N <span class="op">=</span> <span class="fl">50</span><span class="op">)</span> <span class="op">|&gt;</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/logical.html" class="external-link">as.logical</a></span><span class="op">(</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="va">phase_2_sample</span> <span class="op">&lt;-</span> <span class="va">phase_1_sample</span><span class="op">[</span><span class="va">phase_2_sample_indicators</span><span class="op">]</span></span>
<span>  </span>
<span><span class="co"># Estimate two-phase variance</span></span>
<span>  <span class="va">Sigma_a_prime</span> <span class="op">&lt;-</span> <span class="va">Sigma_a</span><span class="op">[</span><span class="va">phase_2_sample_indicators</span>,</span>
<span>                           <span class="va">phase_2_sample_indicators</span><span class="op">]</span></span>
<span>  </span>
<span>  <span class="va">phase_2_joint_probs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/outer.html" class="external-link">outer</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">5</span><span class="op">/</span><span class="fl">50</span>, times <span class="op">=</span> <span class="fl">5</span><span class="op">)</span>,</span>
<span>                               <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">4</span><span class="op">/</span><span class="fl">49</span>, times <span class="op">=</span> <span class="fl">5</span><span class="op">)</span><span class="op">)</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="va">phase_2_joint_probs</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">5</span><span class="op">/</span><span class="fl">50</span>, times <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span>
<span></span>
<span>  <span class="va">Sigma_b</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/make_quad_form_matrix.html">make_quad_form_matrix</a></span><span class="op">(</span></span>
<span>    variance_estimator <span class="op">=</span> <span class="st">"Ultimate Cluster"</span>,</span>
<span>    cluster_ids <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">)</span>,</span>
<span>    strata_ids <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>, times <span class="op">=</span> <span class="fl">5</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>    strata_pop_sizes <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">50</span>, times <span class="op">=</span> <span class="fl">5</span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="op">)</span></span>
<span>  <span class="op">)</span></span>
<span>  </span>
<span>  <span class="va">sigma_ab</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/make_twophase_quad_form.html">make_twophase_quad_form</a></span><span class="op">(</span></span>
<span>    sigma_1 <span class="op">=</span> <span class="va">Sigma_a_prime</span>,</span>
<span>    sigma_2 <span class="op">=</span> <span class="va">Sigma_b</span>,</span>
<span>    phase_2_joint_probs <span class="op">=</span> <span class="va">phase_2_joint_probs</span></span>
<span>  <span class="op">)</span></span>
<span>  </span>
<span>  <span class="va">wts</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span></span>
<span>    <span class="op">(</span><span class="fl">50</span><span class="op">/</span><span class="fl">100</span><span class="op">)</span><span class="op">^</span><span class="op">(</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="fl">5</span><span class="op">/</span><span class="fl">50</span><span class="op">)</span><span class="op">^</span><span class="op">(</span><span class="op">-</span><span class="fl">1</span><span class="op">)</span>,</span>
<span>    times <span class="op">=</span> <span class="fl">5</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">W_star</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="va">wts</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="va">W_star_y</span> <span class="op">&lt;-</span> <span class="va">W_star</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">phase_2_sample</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">W_star_y</span><span class="op">)</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">sigma_ab</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="op">(</span><span class="va">W_star_y</span><span class="op">)</span></span>
<span><span class="co">#&gt; 1 x 1 Matrix of class "dgeMatrix"</span></span>
<span><span class="co">#&gt;          [,1]</span></span>
<span><span class="co">#&gt; [1,] 2182.221</span></span>
<span>  </span>
<span><span class="co"># Since both phases are SRS without replacement,</span></span>
<span><span class="co"># variance estimate for a total should be similar to the following</span></span>
<span>  <span class="fl">5</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/stats/cor.html" class="external-link">var</a></span><span class="op">(</span><span class="va">W_star_y</span><span class="op">)</span></span>
<span><span class="co">#&gt;          [,1]</span></span>
<span><span class="co">#&gt; [1,] 2297.075</span></span></code></pre></div>
</details><p><br></p>
<p>The matrix notation is useful for understanding replication methods
of variance estimation for two-phase samples. Any unbiased replication
variance estimator for two-phase samples should generate each set of
adjustment factors so that the sets of replicate weights have
expectation <span class="math inline">\(\mathbf{1}_{n_b}\)</span> and
variance-covariance matrix <span class="math inline">\(\boldsymbol{\Sigma}_{ab}\)</span>.</p>
<p>The generalized bootstrap does this by generating draws from a
multivariate normal distribution with those parameters. For some
specific combinations of simple first-phase and second-phase designs,
there are jackknife and BRR methods which have been developed to
accomplish this same goal (see <span class="citation">Lohr (2022)</span>
for some examples). The generalized bootstrap however is much easier to
use for the complex designs actually encountered in most settings and
also enjoys other advantages <a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content="&lt;p&gt;See the vignette “Bootstrap Methods for Surveys”&lt;/p&gt;"><sup>3</sup></a>.</p>
</div>
</div>
</div>
</div>
<div class="section level3">
<h3 id="calibration-estimators">Calibration Estimators<a class="anchor" aria-label="anchor" href="#calibration-estimators"></a>
</h3>
<p>This section describes calibration estimators (such as raking,
post-stratification, or ratio estimators) commonly used for two-phase
designs. For a more detailed treatment of such estimators, see Chapter
11 of <span class="citation">Lohr (2022)</span> or Chapter 6 of <span class="citation">Särndal, Swensson, and Wretman (1992)</span>.</p>
<p>In two-phase sampling, it can be helpful to calibrate the weights
from the small second-phase sample <span class="math inline">\(s_b\)</span> so that estimates for variables <span class="math inline">\(x_1, \dots, x_p\)</span> measured in both phases
match the estimates produced using the larger, more reliable sample
<span class="math inline">\(s_a\)</span>. For a variable <span class="math inline">\(y\)</span> measured only in the second-phase
sample, this can lead to more precise estimates if the calibration
variables <span class="math inline">\(x_1, \dots, x_p\)</span> are
associated with <span class="math inline">\(y\)</span>.</p>
<p>If generalized regression (GREG) is used, the two-phase GREG
estimator can be written as follows:</p>
<p><span class="math display">\[
\hat{Y}^{(b)}_{\text{GREG}} = \hat{Y}^{(a)} +
\left(\hat{\mathbf{X}}^{(a)} -
\hat{\mathbf{X}}^{(b)}\right)\hat{\mathbf{B}}^{(b)}
\]</span></p>
<p>where <span class="math inline">\(\hat{\mathbf{X}}^{(a)}\)</span> is
the <span class="math inline">\(p\)</span>-length vector of estimated
population totals for variables <span class="math inline">\(x_1, \dots,
x_p\)</span> estimates using the first-phase data, <span class="math inline">\(\hat{\mathbf{X}}^{(b)}\)</span> is the vector of
estimated population totals using the second-phase data, and <span class="math inline">\(\hat{\mathbf{B}}^{(b)}\)</span> is estimated using
the following:</p>
<p><span class="math display">\[
\hat{\mathbf{B}}^{(b)} = \left(\sum_{i=1}^{n_{(b)}} w^{*}_i
\frac{1}{\sigma_i^2} \mathbf{x}_i \mathbf{x}_i^T\right)^{-1}
\sum_{i=1}^{n_{(b)}} w^{*}_i \frac{1}{\sigma_i^2} \mathbf{x}_i y_i
\]</span></p>
<p>where the constants <span class="math inline">\(\sigma_i\)</span> are
chosen based on the specific type of calibration desired.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt; The specific type of calibration used depends both on
the number and nature of the variables available and on the “working
model” chosen to characterize the relationship between the variables
&lt;span class="math inline"&gt;\(y\)&lt;/span&gt; and &lt;span class="math inline"&gt;\(x_1,\dots,x_p\)&lt;/span&gt;. The choice of calibration
method affects the choice of predictors &lt;span class="math inline"&gt;\(x_1,
..., x_p\)&lt;/span&gt; as well as the choice of constants &lt;span class="math inline"&gt;\(\sigma_i\)&lt;/span&gt; used in the GREG model.&lt;/p&gt;'><sup>4</sup></a></p>
<p>The GREG estimator can also be expressed as a weighted estimator
based on modified weights <span class="math inline">\(\tilde{w}^{*}_i :=
g_i w^{*}_i\)</span> where the modification factor <span class="math inline">\(g\)</span> is suitably chosen for the specific
method of calibration used (post-stratification, raking, etc.)</p>
<p><span class="math display">\[
\begin{aligned}
\hat{Y}^{(b)}_{\text{GREG}} &amp;= \sum_{i=1}^{n_{(b)}} \tilde{w}^{*}_i
y_i = \sum_{i=1}^{n_{(b)}} (g_i w^{*}_i) y_i
\end{aligned}
\]</span></p>
<p>The modification factors <span class="math inline">\(g_i\)</span>
(commonly referred to as “g-weights”) can be expressed as:</p>
<p><span class="math display">\[
g_i = 1+ \left(\hat{\mathbf{X}}^{(a)} -
\hat{\mathbf{X}}^{(b)}\right)^{\prime} \left(\sum_{i=1}^{n_{(b)}}
w^{*}_i \frac{1}{\sigma_i^2} \mathbf{x}_i \mathbf{x}_i^T\right)^{-1}
\sum_{i=1}^{n_{(b)}} w^{*}_i \frac{1}{\sigma_i^2} \mathbf{x}_i
\]</span></p>
<p>The calibrated second-phase weights <span class="math inline">\(\tilde{w}^{*}_i = g_i w^{*}_i\)</span> from the
GREG estimator ensure that the second-phase estimates for the variables
<span class="math inline">\(x_1, \dots, x_p\)</span> match the
first-phase estimates.</p>
<p><span class="math display">\[
\sum_{i=1}^{n_{(b)}} \tilde{w}^{*}_ix_i = \sum_{i=1}^{n_{(a)}}
w^{(a)}x_i
\]</span></p>
<div class="section level4">
<h4 id="variance-of-the-calibration-estimator">Variance of the Calibration Estimator<a class="anchor" aria-label="anchor" href="#variance-of-the-calibration-estimator"></a>
</h4>
<p>If we assume that the second-phase calibration estimator <span class="math inline">\(\hat{Y}_{\mathrm{GREG}}^{(b)}\)</span> is unbiased
for the first-phase estimate <span class="math inline">\(\hat{Y}^{(a)}\)</span> (which should at least
approximately the case), then we can decompose the calibration
estimator’s variance into a first-phase component and a second-phase
component as follows:</p>
<p><span class="math display">\[
\begin{aligned}
V\left(\hat{Y}_{\mathrm{GREG}}^{(b)}\right) &amp;=
V\left[E\left(\hat{Y}_{\mathrm{GREG}}^{(b)} \mid
\mathbf{Z}\right)\right]+E\left[V\left(\hat{Y}_{\mathrm{GREG}}^{(b)}
\mid \mathbf{Z}\right)\right]
\\
&amp;=
V\left[\hat{Y}^{(a)}\right]+E\left[V\left(\hat{Y}_{\mathrm{GREG}}^{(b)}
\mid \mathbf{Z}\right)\right]
\end{aligned}
\]</span></p>
<p>where the first term is the first-phase variance component and the
second term is the second-phase variance component.</p>
<p>Using only the second-phase sample, the variance of the calibration
estimator can thus be estimated unbiasedly by the following
estimator:</p>
<p><span class="math display">\[
V\left(\hat{Y}_{\mathrm{GREG}}^{(b)}\right)
=\hat{V}\left[\hat{Y}^{(a)}\right] + \hat{V}\left[\hat{E}^{(b)} \mid
s_a\right]
\]</span></p>
<p>where <span class="math inline">\(\hat{E}^{(b)} =
\sum_{i=1}^{n_{(b)}} w^{*}e_i\)</span> and <span class="math inline">\(e_i= y_i -
\mathbf{x}^{\prime}_i\hat{\mathbf{B}}^{(b)}\)</span> is the “residual”
of the GREG model.</p>
<p>This is the same as the variance estimator we saw earlier for the
uncalibrated estimator, <span class="math inline">\(\hat{Y}^{(b)}\)</span>, except that the
second-phase component for the GREG estimator uses <span class="math inline">\(\hat{E}^{(b)}\)</span> in place of <span class="math inline">\(\hat{Y}^{(b)}\)</span></p>
<p><span class="math display">\[
\hat{V}\left(\hat{Y}^{(b)}\right) = \hat{V}\left[\hat{Y}^{(a)} \right] +
\hat{V}\left[\hat{Y}^{(b)} \mid s_a \right]
\]</span></p>
<p>This decomposition is useful for understanding the theoretical
variance of the calibration estimator and how it can be estimated in
general.</p>
</div>
<div class="section level4">
<h4 id="replication-variance-estimation">Replication Variance Estimation<a class="anchor" aria-label="anchor" href="#replication-variance-estimation"></a>
</h4>
<p>For variance estimation using replication methods, another
(approximate) decomposition proves to be more useful. <span class="citation">Fuller (1998)</span> decomposes the two-phase
calibration estimator’s variance as follows.</p>
<p><span class="math display">\[
V\left(\hat{Y}_{\mathrm{GREG}}^{(b)}\right) \approx E \left[ V \left(
\tilde{E}^{(b)} \mid s_a \right) \right] + \mathbf{B}^{\prime}
\mathbf{V}\left(\hat{\mathbf{X}}^{(a)}\right)\mathbf{B}
\]</span></p>
<p>where <span class="math inline">\(\mathbf{B}\)</span> is the
finite-population version of <span class="math inline">\(\hat{\mathbf{B}}^{(b)}\)</span> that we could
calculate if we had data from the entire population rather than just the
second-phase sample <span class="math inline">\(s_b\)</span>, and <span class="math inline">\(\tilde{E}^{(b)}=\sum_{i=1}^{n_{(b)}}
w^{*}_i\left(y_i - \mathbf{x}_i^{\prime}\mathbf{B}\right)\)</span> is
the weighted sum of second-phase residuals based on using <span class="math inline">\(\mathbf{B}\)</span>.</p>
<p>This decomposition of the variance suggests the following
estimator:</p>
<p><span class="math display">\[
\hat{V}\left(\hat{Y}_{\mathrm{GREG}}^{(b)}\right) := \hat{V} \left(
\hat{E}^{(b)} \mid s_a \right) + (\hat{\mathbf{B}}^{(b)})^{\prime}
\hat{\mathbf{V}}\left(\hat{\mathbf{X}}^{(a)}\right)(\hat{\mathbf{B}}^{(b)})
\]</span></p>
<p>The first component is estimated using only the second-phase data and
a conditional variance estimator for the second-phase design (taking the
selected first-phase sample as given). The second component depends on
the first-phase estimates <span class="math inline">\(\hat{\mathbf{X}}^{(a)}\)</span> as well as the
first-phase variance estimate <span class="math inline">\(\hat{V}(\hat{\mathbf{X}}^{(a)})\)</span> and the
values <span class="math inline">\(\mathbf{B}^{(b)}\)</span> used in the
calibration.</p>
<p><span class="citation">Fuller (1998)</span> proposed a
replication-based version of this estimator. To describe this estimator,
first we suppose that we have developed two-phase replicate weights
appropriate for the double-expansion estimator.</p>
<p><span class="math display">\[
\begin{aligned}
\hat{V}\left(\hat{Y}^{(b)}\right) &amp;= K_{(b)}\sum_{r=1}^{R_{(b)}}
\left( \hat{Y}^{(b)}_{(r)} - \hat{Y}^{(b)} \right)^2 \\
\text{where }&amp; \hat{Y}^{(b)}_{(r)}= \sum_{i=1}^{n_{(b)}}w_{r,i} y_i
\\
&amp; \text{is the }r\text{-th} \text{ replicate estimate} \\
&amp; \text{for the second-phase sample } \\
\text{and }&amp; K_{(b)}\text{ is a constant specific} \\
&amp;\text{to the replication method}
\end{aligned}
\]</span></p>
<p>Now suppose that we have a <span class="math inline">\(k\)</span>-length vector of estimated first-phase
totals, <span class="math inline">\(\hat{\mathbf{X}}^{(a)}\)</span>,
which will be used in calibration of the second phase weights. And we
suppose that these estimated totals also have an estimated
variance-covariance matrix, denoted <span class="math inline">\(\hat{\mathbf{V}}\left(\hat{\mathbf{X}}^{(a)}\right)\)</span>,
which is a <span class="math inline">\(k \times k\)</span> matrix.</p>
<p>Then we can decompose the variance-covariance matrix as follows:</p>
<p><span class="math display">\[
\hat{\mathbf{V}}\left(\hat{\mathbf{X}}^{(a)}\right) = K_{(b)}
\sum_{i=1}^{R_{(b)}} \boldsymbol{\delta}_i^{\prime}
\boldsymbol{\delta}_i
\]</span></p>
<p>where <span class="math inline">\(\boldsymbol{\delta}_i\)</span> is a
vector of dimension <span class="math inline">\(k\)</span>, and <span class="math inline">\(K_{(b)}\)</span> is the constant mentioned
earlier. There are multiple ways to do this decomposition. Two
particularly useful methods are to either use an eigendecomposition, as
suggested by <span class="citation">Fuller (1998)</span>, or instead use
replicate estimates from the first-phase survey, as suggested by <span class="citation">Opsomer and Erciulescu (2021)</span>.</p>
<p>Fuller demonstrates that we can obtain a reasonable variance
estimator for the two-phase calibration estimator by using these <span class="math inline">\(R_{(b)}\)</span> vectors <span class="math inline">\(\boldsymbol{\delta}_{r}\)</span> to form <span class="math inline">\(R_{(b)}\)</span> different control totals to use
as the calibration targets for the <span class="math inline">\(R_{(b)}\)</span> second-phase replicates. In other
words, we simply calibrate the <span class="math inline">\(r\)</span>-th
set of replicate weights to the <span class="math inline">\(r\)</span>-th control total <span class="math inline">\(\hat{\mathbf{X}}^{(a)} +
\boldsymbol{\delta}_{r}\)</span>. Crucially, the order of the vectors
<span class="math inline">\(\boldsymbol{\delta}_{r}\)</span> should be
totally random, so that the vectors <span class="math inline">\(\boldsymbol{\delta}_{r}\)</span> are independent
of the sets of replicate weights <span class="math inline">\(\mathbf{w}_{r}\)</span>.</p>
<p><span class="citation">Fuller (1998)</span> shows that calibrating
the second-phase replicates to the random calibration targets described
above results in a variance estimator that is consistent for the
variance of the two-phase calibration estimator.</p>
<p>This is the underlying estimator described in R code earlier in this
vignette through the use of the functions
<code><a href="../reference/calibrate_to_estimate.html">calibrate_to_estimate()</a></code> or
<code><a href="../reference/calibrate_to_sample.html">calibrate_to_sample()</a></code>. The essential difference between the
two functions is in how they form the vectors <span class="math inline">\(\boldsymbol{\delta}_r\)</span>.</p>
<p>The function <code><a href="../reference/calibrate_to_estimate.html">calibrate_to_estimate()</a></code> forms the vectors
<span class="math inline">\(\boldsymbol{\delta}_{r}\)</span> using an
eigen-decomposition of a specified variance-covariance matrix.</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Print first phase estimates and their variance-covariance</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">first_phase_totals</span><span class="op">)</span></span>
<span><span class="co">#&gt;       TOTCIR     TOTSTAFF </span></span>
<span><span class="co">#&gt; 1648795905.4     152846.6</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">first_phase_vcov</span><span class="op">)</span></span>
<span><span class="co">#&gt;                TOTCIR     TOTSTAFF</span></span>
<span><span class="co">#&gt; TOTCIR   6.606150e+16 5.853993e+12</span></span>
<span><span class="co">#&gt; TOTSTAFF 5.853993e+12 5.747174e+08</span></span>
<span><span class="co">#&gt; attr(,"means")</span></span>
<span><span class="co">#&gt; [1] 1648121469.6     152702.4</span></span>
<span></span>
<span><span class="co"># Calibrate the two-phase replicate design</span></span>
<span><span class="co"># to the totals estimated from the first-phase sample</span></span>
<span><span class="va">calibrated_twophase_design</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/calibrate_to_estimate.html">calibrate_to_estimate</a></span><span class="op">(</span></span>
<span>  rep_design <span class="op">=</span> <span class="va">twophase_boot_design</span>,</span>
<span>  <span class="co"># Specify the variables in the data to use for calibration</span></span>
<span>  cal_formula <span class="op">=</span> <span class="op">~</span> <span class="va">TOTCIR</span> <span class="op">+</span> <span class="va">TOTSTAFF</span>,</span>
<span>  <span class="co"># Supply the first-phase estimates and their variance</span></span>
<span>  estimate <span class="op">=</span> <span class="va">first_phase_totals</span>,</span>
<span>  vcov_estimate <span class="op">=</span> <span class="va">first_phase_vcov</span>,</span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Selection of replicate columns whose control totals will be perturbed will be done at random.</span></span>
<span><span class="co">#&gt; For tips on reproducible selection, see `help('calibrate_to_estimate')`</span></span></code></pre></div>
<p>In contrast, the function <code><a href="../reference/calibrate_to_sample.html">calibrate_to_sample()</a></code> forms
the vectors <span class="math inline">\(\boldsymbol{\delta}_{r}\)</span>
by using replicate estimates from the first-phase sample.</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">calibrated_twophase_design</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/calibrate_to_sample.html">calibrate_to_sample</a></span><span class="op">(</span></span>
<span>  primary_rep_design <span class="op">=</span> <span class="va">twophase_boot_design</span>,</span>
<span>  <span class="co"># Supply the first-phase replicate design</span></span>
<span>  control_rep_design <span class="op">=</span> <span class="va">first_phase_gen_boot</span>,</span>
<span>  <span class="co"># Specify the variables in the data to use for calibration</span></span>
<span>  cal_formula <span class="op">=</span> <span class="op">~</span> <span class="va">TOTCIR</span> <span class="op">+</span> <span class="va">TOTSTAFF</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Matching between primary and control replicates will be done at random.</span></span>
<span><span class="co">#&gt; For tips on reproducible matching, see `help('calibrate_to_sample')`</span></span></code></pre></div>
</div>
</div>
</div>
<div class="section level2">
<h2 id="ensuring-the-variance-estimator-is-positive-semidefinite">Ensuring the Variance Estimator is Positive Semidefinite<a class="anchor" aria-label="anchor" href="#ensuring-the-variance-estimator-is-positive-semidefinite"></a>
</h2>
<p>If you’ve made it this far in the vignette, then you’re probably now
well-aware that variance estimators for two-phase designs are often not
the positive semidefinite quadratic form we’d like them to be. Instead,
they’re usually close to but not quite a positive semidefinite quadratic
form, owing to the difficulty of estimating the first-phase variance
component.<a class="footnote-ref" tabindex="0" data-bs-toggle="popover" data-bs-content='&lt;p&gt;Recall that the first-phase variance component is
estimated by an estimator of an estimator. To be precise, &lt;span class="math inline"&gt;\(\hat{V}\left[\hat{Y}^{(a)} \right]\)&lt;/span&gt; is an
estimate using the second-phase sample &lt;span class="math inline"&gt;\(s_b\)&lt;/span&gt; of the variance estimator &lt;span class="math inline"&gt;\(\tilde{V}\left[\hat{Y}^{(a)}\right]\)&lt;/span&gt; based
on &lt;span class="math inline"&gt;\(s_a\)&lt;/span&gt; that we would have used if
we had observed values of &lt;span class="math inline"&gt;\(y\)&lt;/span&gt; for the
entire first-phase sample.&lt;/p&gt;'><sup>5</sup></a></p>
<p>One solution for handling a quadratic form matrix <span class="math inline">\(\Sigma_{ab}\)</span> which is not positive
semidefinite is to approximate it by <span class="math inline">\(\tilde{\Sigma}_{ab} = \Gamma \Lambda^{*}
\Gamma^{\prime}\)</span>, where <span class="math inline">\(\Gamma\)</span> is a matrix of eigenvalues of
<span class="math inline">\(\Sigma_{ab}\)</span>, <span class="math inline">\(\Lambda\)</span> is the diagonal matrix of
eigenvalues of <span class="math inline">\(\Sigma_{ab}\)</span>, and
<span class="math inline">\(\Lambda^{*}\)</span> is an updated version
of <span class="math inline">\(\Lambda\)</span> where negative
eigenvalues have been replaced by <span class="math inline">\(0\)</span>. This solution is suggested by <span class="citation">Beaumont and Patak (2012)</span> as a general-purpose
solution for implementing the generalized bootstrap when the target
variance estimator that it’s mimicking isn’t positive semidefinite.
<span class="citation">Beaumont and Patak (2012)</span> argue that using
<span class="math inline">\(\tilde{\Sigma}_{ab}\)</span> instead of
<span class="math inline">\(\Sigma_{ab}\)</span> should only result in a
small overestimation.</p>
<div class="section level3">
<h3 id="usage-with-the-generalized-bootstrap">Usage with the Generalized Bootstrap<a class="anchor" aria-label="anchor" href="#usage-with-the-generalized-bootstrap"></a>
</h3>
<p>When the function <code><a href="../reference/as_gen_boot_design.html">as_gen_boot_design()</a></code> is used to create
generalized bootstrap replicate weights, it will warn you if the target
variance estimator is not positive semidefinite and will let you know
that it will therefore approximate the target variance estimator using
the method described above.</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">gen_boot_design</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/as_gen_boot_design.html">as_gen_boot_design</a></span><span class="op">(</span></span>
<span>  design <span class="op">=</span> <span class="va">twophase_design</span>,</span>
<span>  variance_estimator <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span>
<span>    <span class="st">'Phase 1'</span> <span class="op">=</span> <span class="st">"Ultimate Cluster"</span>,</span>
<span>    <span class="st">'Phase 2'</span> <span class="op">=</span> <span class="st">"Ultimate Cluster"</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="co">#&gt; Warning in as_gen_boot_design.twophase2(design = twophase_design,</span></span>
<span><span class="co">#&gt; variance_estimator = list(`Phase 1` = "Ultimate Cluster", : The sample</span></span>
<span><span class="co">#&gt; quadratic form matrix for this design and variance estimator is not positive</span></span>
<span><span class="co">#&gt; semidefinite. It will be approximated by the nearest positive semidefinite</span></span>
<span><span class="co">#&gt; matrix.</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="helper-functions-for-ensuring-an-estimator-is-positive-semidefinite">Helper Functions for Ensuring an Estimator is Positive
Semidefinite<a class="anchor" aria-label="anchor" href="#helper-functions-for-ensuring-an-estimator-is-positive-semidefinite"></a>
</h3>
<p>The ‘svrep’ package has two functions which can be helpful for
dealing with matrices which we hope are positive semidefinite but which
might not be.</p>
<p>The function <code><a href="../reference/is_psd_matrix.html">is_psd_matrix()</a></code> simply checks whether a
matrix is positive semidefinite. It works by estimating the matrix’s
eigenvalues and determining whether any of them are negative.</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">twophase_quad_form_matrix</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get_design_quad_form.html">get_design_quad_form</a></span><span class="op">(</span></span>
<span>  design <span class="op">=</span> <span class="va">twophase_design</span>,</span>
<span>  variance_estimator <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span></span>
<span>    <span class="st">'Phase 1'</span> <span class="op">=</span> <span class="st">"Ultimate Cluster"</span>,</span>
<span>    <span class="st">'Phase 2'</span> <span class="op">=</span> <span class="st">"Ultimate Cluster"</span></span>
<span>  <span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">twophase_quad_form_matrix</span> <span class="op">|&gt;</span> <span class="fu"><a href="../reference/is_psd_matrix.html">is_psd_matrix</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] FALSE</span></span></code></pre></div>
<p>If the matrix isn’t positive semidefinite (but is at least
symmetric), then the function <code><a href="../reference/get_nearest_psd_matrix.html">get_nearest_psd_matrix()</a></code> will
implement the approximation method described earlier.</p>
<p>Approximating this quadratic form by one which <em>is</em> positive
semidefinite leads to a very similar (but slightly larger) estimated
standard error.</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">approx_quad_form</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/get_nearest_psd_matrix.html">get_nearest_psd_matrix</a></span><span class="op">(</span><span class="va">twophase_quad_form_matrix</span><span class="op">)</span></span></code></pre></div>
<p>In the example two-phase design based on the library survey from
earlier, we can see that this approximation results in a standard error
estimate which is only slightly larger than the standard error estimate
based on the quadratic form which wasn’t quite positive
semidefinite.</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Extract weights and a single variable from the second-phase sample</span></span>
<span><span class="co">## NOTE: To get second-phase data,</span></span>
<span><span class="co">##       we use `my_design$phase1$sample$variables`.</span></span>
<span><span class="co">##       To get first-phase data,</span></span>
<span><span class="co">##       we use `my_design$phase1$full$variables</span></span>
<span></span>
<span><span class="va">wts</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/weights.html" class="external-link">weights</a></span><span class="op">(</span><span class="va">twophase_design</span>, type <span class="op">=</span> <span class="st">"sampling"</span><span class="op">)</span></span>
<span><span class="va">y</span> <span class="op">&lt;-</span> <span class="va">twophase_design</span><span class="op">$</span><span class="va">phase1</span><span class="op">$</span><span class="va">sample</span><span class="op">$</span><span class="va">variables</span><span class="op">$</span><span class="va">TOTSTAFF</span></span>
<span><span class="va">wtd_y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="va">wts</span> <span class="op">*</span> <span class="va">y</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Estimate standard errors</span></span>
<span><span class="va">std_error</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">wtd_y</span><span class="op">)</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">twophase_quad_form_matrix</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">wtd_y</span></span>
<span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="va">approx_std_error</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html" class="external-link">as.numeric</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">wtd_y</span><span class="op">)</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">approx_quad_form</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">wtd_y</span></span>
<span><span class="op">)</span> <span class="op">|&gt;</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">approx_std_error</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 20498.68</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">std_error</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 19765.59</span></span>
<span></span>
<span><span class="va">approx_std_error</span> <span class="op">/</span> <span class="va">std_error</span></span>
<span><span class="co">#&gt; [1] 1.037089</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-beaumont2012" class="csl-entry">
Beaumont, Jean-François, and Zdenek Patak. 2012. <span>“On the
Generalized Bootstrap for Sample Surveys with Special Attention to
Poisson Sampling: <span><em>Generalized Bootstrap for Sample
Surveys</em></span>.”</span> <em>International Statistical Review</em>
80 (1): 127–48. <a href="https://doi.org/10.1111/j.1751-5823.2011.00166.x" class="external-link">https://doi.org/10.1111/j.1751-5823.2011.00166.x</a>.
</div>
<div id="ref-Fuller1998" class="csl-entry">
Fuller, Wayne A. 1998. <span>“Replication <span>Variance
Estimation</span> for <span>Two-Phase Samples</span>.”</span>
<em>Statistica Sinica</em> 8 (4): 1153–64.
</div>
<div id="ref-lohrSamplingDesignAnalysis2022" class="csl-entry">
Lohr, Sharon L. 2022. <em>Sampling: Design and Analysis</em>. Third
edition. Chapman &amp; <span>Hall CRC</span> Texts in Statistical
Science. <span>Boca Raton</span>: <span>CRC Press</span>.
</div>
<div id="ref-opsomerReplicationVarianceEstimation2021" class="csl-entry">
Opsomer, J. D., and A. L. Erciulescu. 2021. <span>“Replication Variance
Estimation After Sample-Based Calibration.”</span> <em>Survey
Methodology, Statistics Canada</em> Vol. 47 (No. 2).
</div>
<div id="ref-sarndalModelAssistedSurvey1992" class="csl-entry">
Särndal, Carl-Erik, Bengt Swensson, and Jan Wretman. 1992. <em>Model
<span>Assisted Survey Sampling</span></em>. Springer <span>Series</span>
in <span>Statistics</span>. <span>New York, NY</span>: <span>Springer
New York</span>.
</div>
</div>
</div>

  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Ben Schneider.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
